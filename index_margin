mt = require 'margin_trading' 
talib = require 'talib'
params = require 'params'

ACC_P = params.add "Acc Bands period", 70
SS_PCT = params.add "Short Stop %", 12
LS_PCT = params.add "Long Stop %", 12
	
class Margin

    @OpenShort: (pos, instrument, shortPrice, shortAmount, marginInfo) ->
        if (pos)
            mt.closePosition instrument
        if (mt.sell instrument, 'limit', shortAmount/shortPrice, shortPrice)
            return true
        return false

    @OpenLong: (pos, instrument, longPrice, longAmount, marginInfo) ->
        if (pos)
            mt.closePosition instrument
        if (mt.buy instrument, 'limit', longAmount/longPrice, longPrice)
            return true
        return false

    @OpenPositionPL: (currentPrice, marginPosition) ->
        pl = ((currentPrice - marginPosition.price)/marginPosition.price) * 100
        if (marginPosition.amount < 0)
            return -pl
        else
            return pl

    @OpenPositionCurrentBalance: (currentPrice, startingBalance, marginPosition) ->
        return (startingBalance + marginPosition.amount * (currentPrice - marginPosition.price))

init: -> 	
    #Initialize things
    storage.initializedS ?= false
    storage.initializedL ?= false

handle: ->
    i = @data.instruments[0]
    info = mt.getMarginInfo i
    pos = mt.getPosition i	
    storage.shortPrice ?= null
    storage.longPrice ?= null
    storage.longPrice ?= null
    storage.longStop ?= null
    storage.shortStop ?= null

#ACC BANDS   
    results = talib.ACCBANDS
	      high: i.high
	      low: i.low
	      close: i.close
	      startIdx: 0
	      endIdx: i.high.length - 1
	      optInTimePeriod: ACC_P
    
    uB = results.outRealUpperBand
    mB = results.outRealMiddleBand
    lB = results.outRealLowerBand
#short	    
    if (!storage.initializedS and !storage.shortStop and (i.price >= _.last(uB)))
        if (@Margin.OpenShort(pos, i, i.price, info.tradable_balance, info))
            storage.startBalance = info.margin_balance
            storage.initializedS = true
            storage.initializedL = false
            storage.shortPrice = i.price
            storage.shortStop = false
            storage.longStop = false
        warn "Finished Short Order!"
    if storage.initializedS and !storage.shortStop
    		SstopOrder = mt.addOrder 
      		instrument: i
      		side: 'buy'
      		type: 'limit'
      		amount: info.tradable_balance
      		price: storage.shortPrice * 1.SS_PCT
	    	storage.initializedS = false
	    	storage.shortStop = true
    if SstopOrder
        warn "Finished Short Stop Order!"
#long	            	            
    if (!storage.initializedL and !storage.longStop and (i.price <= _.last(lB)))
        if (@Margin.OpenLong(pos, i, i.price, info.tradable_balance, info))
            storage.startBalance = info.margin_balance
            storage.initializedL = true
            storage.initializedS = false
            storage.longPrice = i.price
            storage.shortStop = false
            storage.longStop = false
        warn "Finished Short Order!"
    if storage.initializedL and !storage.longStop
    		LstopOrder = mt.addOrder 
      		instrument: i
      		side: 'sell'
      		type: 'limit'
      		amount: info.tradable_balance
      		price: storage.longPrice * 0.LS_PCT
	    	storage.initializedS = false
	    	storage.longStop = true
    if SstopOrder
        warn "Finished Long Stop Order!"

#plot print
    debug "---------- BuyTFdip's Margin Bot ----------"
    debug "Current Price: #{i.price.toFixed(8)} #{i._pair[1].toUpperCase()}"
    debug "Current Position: #{pos.amount} #{i._pair[0].toUpperCase()} at #{pos.price} #{i._pair[1].toUpperCase()}"
    debug "Current Position P/L: #{@Margin.OpenPositionPL(i.price, pos).toFixed(2)}%"
    debug "Margin balance: #{info.margin_balance} #{i._pair[1].toUpperCase()}"
    debug "Tradeable balance: #{info.tradable_balance} #{i._pair[1].toUpperCase()}"
    debug "----------------------------------------------"
    debug " "
    plot
        "Upper Band": _.last(uB)
    plot
        "Mid Band": _.last(mB)
    plot
        "Lower Band": _.last(lB) 

onStop: ->
    i = @data.instruments[0]
    # unlike orders open positions don't get cancelled when the bot is stopped
    # the below snippet can be used to programmatically close it
    pos = mt.getPosition i
    if pos
        debug "Closing position"
        mt.closePosition i
